一、并发问题的源头：
1、缓存导致的可见性问题
2、线程切换带来的原子性问题
3、编译优化带来的有序性问题

二、java内存模型
java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。
具体包括：
    三个关键字：
    volatile
    synchronized
    final
    六项happen-before 规则: 前面一个操作的结果对后续操作是可见的

happen-before:
1、程序的顺序性规则
2、volatile 变量规则
3、传递性
4、管程中锁的规则:指对一个锁的解锁happen-before 于后续对这个锁的加锁
   管程是一种通用的同步原语，在java中指的就是synchronized,synchronized 就是对管程的实现。
5、线程start()规则
   这条是关于线程启动的。它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。
    Thread B = new Thread(()->{
      // 主线程调用 B.start() 之前
      // 所有对共享变量的修改，此处皆可见
      // 此例中，var==77
    });
    // 此处对共享变量 var 修改
    var = 77;
    // 主线程启动子线程
    B.start();

6、线程join()规则
   关于线程等待。指主线程A等待子线程B 完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join（）方法返回），主线程能够看到子线程的操作。
   Thread B = new Thread(()->{
     // 此处对共享变量 var 修改
     var = 66;
   });
   // 例如此处对共享变量修改，
   // 则这个修改结果对线程 B 可见
   // 主线程启动子线程
   B.start();
   B.join()
   // 子线程所有对共享变量的修改
   // 在主线程调用 B.join() 之后皆可见
   // 此例中，var==66





